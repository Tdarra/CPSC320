% ======================= Pre-Amble =========================
      
%Format
\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format 
                     						%imports package {article} and specify option(s) [11pt, oneside]
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots. 
    \geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
    %\geometry{landscape}                		% Activate for rotated page geometry

\usepackage[parfill]{parskip}    		        % Activate to begin paragraphs with an empty line rather than an indent

    %Colours
    \usepackage{graphicx, subcaption}
    \usepackage[usenames, dvipsnames]{color}     % font colour:    \textcolor{<colour>}{text}
          									%highlight text:  \colorbox{<color>}{text}
    \usepackage{soul}						%highlight text: \hl{}     %only  yellow								
    									%list of colours: https://www.sharelatex.com/learn/Using_colours_in_LaTeX
    									
    %Bullets
    \usepackage{enumerate}     %specify type of enumeration: \being{enumerate}[<type of enumeration>]
    
    %Footnote Spacing
    \setlength{\footnotesep}{0.4cm}                  %specify spacing b/w footnotes
    \setlength{\skip\footins}{0.6cm}                    % space b/w footnotes and textbody

	%Sections
%	\makeatletter
%	% we use \prefix@<level> only if it is defined
%	\renewcommand{\@seccntformat}[1]{
%	  \ifcsname prefix@#1\endcsname
%	    \csname prefix@#1\endcsname
%	  \else
%	    \csname the#1\endcsname\quad 
%	  \fi}
%	% define \prefix@section
%	\newcommand\prefix@section{Question \thesection}
%	\makeatother

%	\makeatletter
%	\def\@seccntformat#1{%
%	  \expandafter\ifx\csname c@#1\endcsname\c@section
%	  Question \thesection
%	  \else
%	  \csname the#1\endcsname\quad
%	  \fi}
%	\makeatother



%Mattematics
    %American Mathematics Society packages
    \usepackage{amsmath}	   %math
    \usepackage{amssymb}       %symbols
    \usepackage{amsthm}          %theorems
    \newtheorem{proposition}{Proposition}

    %QED
    \newcommand*{\QEDA}{\hfill\ensuremath{\blacksquare}}         %make qed filled square:    \QEDA
    \newcommand*{\QEDB}{\hfill\ensuremath{\square}}               %make qed empty square: \QEDB 
    \renewcommand\qedsymbol{\ensuremath{\blacksquare}}		%Proof environment
    
    % Proofs
	\newtheorem{thm}{Theorem}[section]
	\newtheorem{lem}[thm]{Lemma}
	\newtheorem{prop}[thm]{Proposition}
	\newtheorem*{cor}{Corollary}
	
	\theoremstyle{definition}
	\newtheorem{defn}{Definition}[section]
	\newtheorem{conj}{Conjecture}[section]
	\newtheorem{exmp}{Example}[section]
	
	\theoremstyle{remark}
	\newtheorem*{rem}{Remark}
	\newtheorem*{note}{Note}
	
	% Symbol Shortcuts
	\newcommand{\R}{\ensuremath{\mathbb{R}}}
	\newcommand{\C}{\ensuremath{\mathbb{C}}}
	\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
	\newcommand{\Q}{\mathbb{Q}}
	\newcommand{\N}{\mathbb{N}}
	
	% Augmented Matrix
	\makeatletter
	\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
  	\hskip -\arraycolsep
 		 \let\@ifnextchar\new@ifnextchar
 		 \array{#1}}
	\makeatother
	
    %\numberwithin{counterA}{counterB} 	% replaces counterA by counterb.countera
	%\numberwithin{equation}{question} 	% for equations: (5) -> (6.1)
    
    % Spacing Units
	\usepackage{siunitx}				% Syntax: \SI{value}{unit}
								%	-> e.g. $\SI{-9.81}{ms^{-2}}$
	
    % MATLAB in sentence (need mcode.sty in folder)
	%\usepackage[]{mcode} % http://www.mathworks.com/matlabcentral/fileexchange/8015-m-code-latex-package
	% Syntax:
	%	- In Sentence: \mcode{<code>}
	%	- Block of code: \begin{lstlisting} <code> \end{lstlisting}
	%	- Footnote: \footnote{ \mcodefn{ <code> } }
	%	- External m-file
	%		-> Entire file: \lstinputlisting{/SOME/PATH/FILENAME.M}
	%		-> Certain lines (i.e. skip header): \lstinputlisting[firstline=6, lastline=15]{/SOME/PATH/FILENAME.M}



%Figures
\usepackage{caption}
\captionsetup[figure]{labelfont=bf}    %make figure labels boldface
\captionsetup[table]{labelfont=bf}     %make table labels boldface

\usepackage[hidelinks]{hyperref}                % Allows for clickable references

    %Tables
    \usepackage[none]{hyphenat}                    % Stops breaking-up words in a table (i.e. no hyphens)                                                             
    
    \usepackage{array}   
        \newcolumntype{x}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}       %center fixed column width: x{<len>}                      
        \newcolumntype{$}{>{\global\let\currentrowstyle\relax}}                                 % let us apply things (e.g. bold/italicize) to entire row            
        \newcolumntype{^}{>{\currentrowstyle}}
        \newcommand{\rowstyle}[1]{\gdef\currentrowstyle{#1} #1\ignorespaces}
    
    %Images
    \graphicspath{ {images/} }                          %directory that your images are located in within your current directory
    
    %Diagrams
    \usepackage[latin1]{inputenc}
    \usepackage{tikz}
    	\tikzset{line/.style={-latex'}}
        \usepackage{tkz-berge}
        \usetikzlibrary{shapes,arrows}
        \usetikzlibrary{patterns}			%Specify colours of stuff (e.g. vertices): 
        										%	-> set style: \tikzset{VertexStyle/.append style = {minimum size = 8pt, inner sep = 0pt}} 
											%	-> change individual vertices: \AddVertexColor{white}{1,2} 


%Bibliography
\usepackage[numbers,sort&compress]{natbib}   %for multiple references: sorts  (i.e. [1,2] NOT [2, 1] )
                                           				  %                                     compresses (i.e. [1-3] )
\usepackage[nottoc]{tocbibind}                            %add bibliography to table of contents


%Miscellaneous
\usepackage{dirtytalk}    %quotations: use \say  
\usepackage{wasysym} 	 % \smiley{} \frownie{} \blacksmiley{}
\usepackage{hyperref}
\usepackage{algpseudocode}


%================================== Header & Footer =======================================
\usepackage{fancyhdr}
\usepackage{lastpage}      %ensures you can reference LastPage (i.e. Page 2 of 10)

\renewcommand{\headrulewidth}{0.4pt}		%Decorative Header line: thickness={0.4pt}
\renewcommand{\footrulewidth}{0.4pt}		%Decorative Footer line: thickness={0.4pt}

\setlength{\headheight}{13.6pt} 		%space b/w top of page & header
\setlength{\headsep}{0.3in}		%space b/w page header and body

%Make Header & Footer    
\pagestyle{fancy}
    \lhead{S. Knill and T. Darra} 		% controls the left corner of the header
    \chead{} 					% controls the center of the header
    \rhead{} 					% controls the right corner of the header
    \lfoot{} 					% controls the left corner of the footer
    \cfoot{Page~\thepage\ of \pageref{LastPage}} 				% controls the center of the footer
    												%Page~\thepage\  if just want Page x
    \rfoot{}			 		% controls the right corner of the footer


% ================================== Document =============================================
\begin{document}

% Title Page
\title{CPSC 320 --- Assignment 2 \\
\line(1,0){360} \\              %(slope x, y){length of line}
}
\author{
Stephanie Knill (54882113) \\
Taj Darra (43350115) \\
Due: October 6, 2016}

\date{}                   % Activate:  display a given date (e.g. {August 4} ) or no date (empty {} )
                                    %No activate: display current date
\maketitle

%\thispagestyle{empty}                   %Remove header from this (first) page. Change empty -> plain to keep numbering
%								-> Doesn't matter in this case (b/c title page)
%\cleardoublepage


% ================= Questions ================

\section*{Collaboration Policy}
\emph{All group members have read and followed the guidelines for academic conduct in CPSC 320. As part of those rules, when collaborating with anyone outside my group, (1) I and my collaborators took no record but names away, and (2) after a suitable break, my group created the assignment I am submitting without help from anyone other than the course staff.}

\section{Olympic Scheduling}
You are in charge of a live-streaming YouTube channel for the Olympics
that promises never to interrupt an event. (So, once you start playing
an event, you must play only that event from the time it starts to the
time it finishes.) You have a list of the events, where each event
includes its: \textbf{start time, finish time (which must be after its start time), and expected audience value}. Your goal is to \textbf{make a schedule to broadcast the most valuable complete events}. \textbf{The best schedule is the one with the highest-valued event}; \textbf{in case of ties, compare second-highest valued events, and so on}. (So, for example, you
obviously \textbf{will} include the single highest-valued event in the
Olympics---presumably the hockey gold medal game---no matter what else
it blocks you from showing.)

(Times when you're not broadcasting events will be filled with ``human
interest stories'' that have zero value; so, they're irrelevant.)

\textbf{ASSUME: all event values are distinct and all event times are distinct.} I.e., for any two values $v_i$ and $v_j$ with $i \neq j$,
$v_i \neq v_j$. The same holds for start and end times (e.g., for any
two start times $s_i$ and $s_j$ with $i \neq j$, $s_i \neq
s_j$). Further, for any two start and finish times $s_i$ and $f_j$,
whether $i = j$ or not, $s_i \neq f_j$.
\subsection{Na\"ive Algorithm}

Consider the following algorithm. Assume that deleting an event from a
list of events takes constant time.

\begin{verbatim}
Naive(E):
  result = new empty list of events
  while E is not empty:
    bestEvent = E[0]
    for each e in E:
      if value(e) > value(bestEvent):
        bestEvent = e
    delete bestEvent from E
    for each e in E:
      if start(e) < finish(bestEvent) and finish(e) > start(bestEvent):
        delete e from E
    add bestEvent to result
  return result
\end{verbatim}
\subsubsection{Finiteness}

Briefly sketch a proof that the \texttt{while} loop in the algorithm above
terminates. You need not give a formal proof, but you should include
all key insights in the proof.

\textbf{Representing the problem:} Let $E$ denote the set of all events to be streamed $E=\left\{e_1, \dotsm, e_n\right\}$ where $n=|E|.$ For every event $e \in E$, let $e$ comprise an ordered triple $e_i = (v_i, s_i, f_i)$ where $v,s$ and $f$ denote the audience value, start time, and finish time accordingly.

\begin{proof}
Let $n$ be the cardinality of $E$ (i.e. $n=|E|$).

\textbf{Base Case:} if $n = 0$, then the while loop is never intiated
Otherwise if $n=1$ then the event $e$ where $e \in E$ is the bestEvent as assigned and is removed after the execution of the first for loop. 

\textbf{Inductive Step:} Assume true for $n=k$ events, then for $n=k+1$ events we have two cases as such:
\begin{itemize}
	\item In the first case, we delete the bestEvent and no conflicting events leaving us with $n=k+1-1=k$. By the inductive assumption the algorithm holds true.
	\item As for the second case, we delete the bestEvent and some number of events which leaves u with $n<k$. By the inductive step, the algorithm holds true.
\end{itemize} 
\end{proof}
\subsubsection{Efficiency}

\textit{Give and briefly justify a good asymptotic bound on the runtime of the algorithm.}

Assuming all elementary operation execute in constant time, the worst case executions are $O(n^2)$ where the worst case execution is defined as when we only delete the assigned bestEvent and there are no conflicts.  Within the outer while loop, the first for loop executes $n$ times for comparing the values of bestEvent and another event $e$. Then for every iteration of the while loop, we delete the bestEvent in constant time. Finally, the ending nested for loop executes $(n-1)$ per iteration. Then we add bestEvent at constant time. In total, we have: $$n\big(n+1+(n-1)+1\big) = O(n^2)$$
\subsubsection{Correctness}
\textit{Briefly sketch a proof that the algorithm is correct. You need not give a formal proof, but you should include all key insights in the
proof.}

\textbf{Correctness:} Let us define a correct solution returned by the algorithm as a set $R \subset E$. For $R=\{r_1, r_2, \ldots, r_k\}$, we have that $v_1 > v_2 > \ldots > v_k$. And to prevent conflicted showtimes of events we have $ \forall r_i, r_j \in R, \text{if } s_i < s_j, \text{then } f_i < s_j$; or less formally, if an event in our schedule $R$ begins before the next event, then it will also end before the start of our next event.
\begin{proof}
We will show that the Naive(E) algorithm returns a correct solution but not necessarily the optimal solution. If we can show that (1) the bestEvent (i.e. $e_i\in E$ such that $v_i$ is a max) is removed from $E$ and added to our result $R$, (2) all conflicting events to bestEvent are removed from $E$, and (3) the algorithm repeats steps (1) and (2) for all remaing events in $E$, then we have shown Naive(E) returns a correct solution. 
	\begin{enumerate}
		\item The bestEvent $e_\text{best}$ is assigned as the first element of $E$, then the value of the bestEvent is compared to the value of another element, $e_\text{other}$ . If $v_\text{other} > v_\text{best}$ then we assign the bestEvent $e_\text{best} = e_\text{other}$. Hence, $v_\text{best}$ is the maximum audience value in $E$.
		
		After the execution of the first for loop, we remove the bestEvent from $E$ and regardless of the execution of the second for loop this bestEvent is added to $R$.
		
		\item In order to handle the conflicts, the second for loop removes events that satisfy the following condition: for all $ e_i \in E - \{e_\text{best}\}$ if an event $e_i$ has a start time before or during the bestEvent (i.e. $s_i < f_\text{best}$), and the finish time of $e_i$ is during or after the bestEvent (i.e. $f_i > s_\text{best}$), then the event $e_i$ interrupts the bestEvent. To see why, let us break the start time of $e_i$ into two cases.
		
			\textbf{Case 1:} event $e_i$ starts before the bestEvent. If $e_i$ ends after the start of the bestEvent (i.e. the second condition $f_i > s_\text{best}$), then we have an overlap.
		
			\textbf{Case 2}: event $e_i$ starts during the bestEvent. By definition, we have an overlap.
		
		\item After steps (1) and (2) we are now left with the subset $E' \subset E$, such that $E'$ does not contain the bestEvent (1) and any conflicting events (2). According to the while loop, if $E'$ is non-empty, then the algorithm will repeat steps (1) and (2) for this new $E'$.
	\end{enumerate}
\end{proof}
\subsection{Reduction on Simplified Problem}

To make the Olympic Broadcasting problem simpler, we completely remove
start time and finish times from the problem. So, now events only have
values (not times), and a ``schedule'' is just a set of selected
events. To make it slightly harder again, you are not allowed to
select two events $i$ and $j$ if their values are within 10 units of
each other: $|v_i - v_j| \leq 10$.

Give a correct reduction from this simplified Olympic Broadcasting
problem to the sorting problem (where you provide both a list of items
and a function to compare two items). Your reduction should take $O(n
\lg n)$ time.

\textbf{Reduction: } We will reduce the Olympic Broadcasting problem to a Heapifying Array problem. In order to do this we will recycle the set of all events $E$ and pass it as an array to Heapify(E). This will return our desired schedule of events as $H$. This will take $O(n \lg n)$. For our comparaison function, we want to know if we can add an event $e_j$ if we have already added event $e_i$. The pseudocode is given below.

\begin{verbatim}
	canAdd(e_i, e_j):
	  if |value(e_i) - value(e_j)| > 10
	    return true
	  else
	    return false	
\end{verbatim} 

\textbf{Translation to Olympic Broadcasting: } Now that we have our resulting $H$, for all events $e \in H$ and their respective values we have $v_1 > v_2 > \dotsm> v_k$ where $k =|H|$. This satisfies the first half of our definition of correctness from 1.1.3. 

\textbf{NOTE:} You will likely find that (a) you can solve this with a single
call to the sorting problem's solution algorithm and (b) producing the
sorting instance is the easier part and transforming the solution to
sorting into a solution to this simplified Olympic Broadcasting
problem is the harder part. Don't forget to do both!
\subsection{Olympic Reduction, BONUS ONLY}

This was significantly harder than we intended it to be! So, we
removed it from the quiz/assignment. It's a bonus problem worth two
CPSC 320 bonus points for extremely clear, correct, and efficient
responses. (Extremely clear reductions that take $O(n)$ time---not
counting an $O(1)$ number of calls to a sorting algorithm---may
receive 3 bonus points, but we don't know if such reductions are
possible.)

Give a correct and efficient reduction from the Olympic broadcasting
problem to the sorting problem (where you provide both a list of items
and a function to compare two items). Your reduction---combined with
an $O(n \lg n)$ sorting algorithm---should be asymptotically more
efficient than the na\"ive algorithm above.
\subsubsection{Correctness}

Briefly sketch a proof that your algorithm is correct. You need not
give a formal proof, but you should include all key insights in the
proof.
\subsubsection{Efficiency}

Give and briefly justify a good asymptotic bound on the runtime
of \textbf{just} your reduction, \textbf{not} including the call to the sorting
algorithm. So, for the purposes of this asymptotic bound, you can
imagine that we somehow solve sorting in constant time. (Note: it's
possible to give a reduction that takes $O(n)$ time.)




\section{Exhausted of Marriage}

We modify SMP with the very reasonable change that not every woman
need list every man in her preferences. She prefers to be unmarried to
marrying unlisted men. Note that she clearly prefers any man on her
preference list to any man not on her preference list. Men can
similarly truncate their lists of women.

Here is the Gale-Shapley algorithm:
  \begin{algorithmic}[1]
  \Procedure{Stable-Marriage}{$M$, $W$}
    \State initialize all men in $M$ and women in $W$ to unengaged
    \While {an unengaged man with at least one woman on his preference list remains}
      \State choose such a man $m \in M$
      \State propose to the next woman $w \in W$ on his preference list
      \If {$w$ is unengaged}
        \State engage $m$ to $w$
      \ElsIf {$w$ prefers $m$ to her fianc\'e $m'$}
        \State break engagement of $m'$ to $w$
        \State engage $m$ to $w$
      \EndIf
      \State cross $w$ off $m$'s preference list
    \EndWhile
    \State report the set of engaged pairs as the final matching
  \EndProcedure
  \end{algorithmic}
With one small change, we can apply this algorithm and ensure that the
(not necessarily perfect) matching produced never marries a person to
someone they left off of their preference list.
\begin{enumerate}
	\item Make the small change necessary \textbf{to the algorithm above}.

	\qquad Line 6: if ($w$ is unengaged \& $m$ in $w$'s preference list) then

	\item Briefly sketch the key elements of a proof that the algorithm terminates.
	
	In the worst case, the algorithm will terminate in $n^2$ iterations, i.e. men have complete preference lists. Let $S(k)$ be the set of pairs $(m, w)$ such that $m$ has proposed to $w$ on iteration $k$ of the Gale-Shapley algorithm. Then we can see that every new iteration increases the number of pairs (or in mathematical notation: $\forall k, |S(k+1)| > S(k)$). However, since in the worst case we have $n^2$ possible pairs of men and women we know that there can be at most $n^2$ iterations of the while loop, hence the algorithm must terminate.
	
	
	\item We need a new definition of instability now that some people may
   end up unmarried. Here is one new type of instability that we call
   an \emph{elopement instability}: m$_i$ and w$_j$ are both unmarried but list
   each other on their preference lists (in which case they have
   incentive to break the imposed matching and marry each other).
   
   Describe another new type of instability involving an unmarried
   woman. (Note: an analogous instability exists involving an
   unmarried man.)
   
   \textbf{The mistress instability: } We can define a new instability with the following conditions:
   		\begin{enumerate}
   			\item $w_j$ is unmarried, $m_i$ is married
   			\item $w_j$ prefers $m_i$ to being unmarried 
   			\item $m_i$ prefers $w_j$ to current partner
   
   \end{enumerate}
   \textbf{The poolboy instability: }\textit{(to be referenced in 2.1)} An instability analogous to the above has the following conditions: 
   \begin{enumerate}
   			\item $w_j$ is married, $m_i$ is unmarried
   			\item $w_j$ prefers $m_i$ to current partner
   			\item $m_i$ prefers $w_j$ to being unmarried
   
   \end{enumerate}
	\item Briefly sketch the key elements of a proof that your modified G-S algorithm cannot generate an elopement instability.
	
	\begin{proof}
		In order to show that the \textit{elopement instability} is not a feasible result of the modified G-S algorithm, we will show that the algorithm terminates with a man left married or unmarried  with an empty preference list. The precondition of the \textbf{while} loop outlines that an unengaged man must have a preference list, otherwise we terminate the procedure. This means that we cannot have an unengaged man and unengaged woman that prefer each other. This is because the while loop ensures that every man gets engaged or is left with an empty preference list. In the case of the latter, it is not possible that an unmarried man prefers any woman.
	\end{proof}
\end{enumerate}
\subsection{Even More Exhausted}

Briefly sketch the key elements of a proof that your modified G-S
algorithm cannot generate any of the other three types of instability
(the classic SMP instability, the instability you defined above, and
the analogous instability with the roles of men and women swapped).
\section{Footblog}

The massive social network Footblog tracks relationships based on
whether two people have ``enemied'' each other. (``Enemyship'' is a mutual
agreement, meaning that a person is not allowed to ``enemy'' another
person unless the other person agrees to ``enemy'' them back. No one can
``enemy'' themselves.)
\subsection{Isolationism}

We investigate whether Footblog's network is a single connected
component.

Footblog's founder created the first Footblog account, and that
account has no ``sponsor'' (and cannot be assigned one). Every other
account must have a single, designated ``sponsor'' who they have
``enemied''. If $a$ sponsors $b$, we call $b$ the \emph{sponsee} of $a$.

There are then four major actions to consider on Footblog, some of
which involve others as steps:
\begin{description}
\item[\emph{Joining}] When a new Footblog member joins, they must do so by
               choosing as sponsor (and ``enemying'') someone already in
               the network who agrees to be their sponsor (and their
               enemy). After members join, they're free to ``enemy''
               and ``unenemy'' anyone except their sponsor and their
               sponsees.
\item[\emph{Enemying}] Already described above. Remember that when one person
                ``enemies'' another, the other must agree to ``enemy''
                that person back.
\item[\emph{Un-Enemying}] Unlike making an ``enemy'' link, one person alone can
                   ``unenemy'' another person, in which case neither
                   ``enemies'' the other any more.
\item[\emph{Change Sponsor}] If a person wishes to change their sponsor, they
     must ``unenemy'' their sponsor and simultaneously ``enemy'' a new
     sponsor. The new sponsor must agree to act as sponsor and enemy
     and \textbf{must be a new enemy} (i.e., must not already be the person's
     enemy). Note that while a sponsee can choose to change their
     sponsor, a sponsor cannot choose to change their sponsee.
\end{description}

You may assume these actions never happen in parallel, i.e., a defined
sequence occurs of the operations: joining, enemying, un-enemying, and
changing sponsors.
\begin{enumerate}
\item Based on these rules, sketch a brief proof that when a person
   changes their sponsor, their new sponsor cannot also be one of
   their sponsees.
\item Based on these rules, either \textbf{sketch the key points in a proof that    Footblog's enemy graph forms a single connected component} or \textbf{give    a small sequence of actions that creates multiple components}.
   
   Circle \textbf{one}: \hfill \textbf{SINGLE ONLY} \hfill \textbf{MAY BE MULTIPLE} \hfill

   \textbf{Provide your proof sketch or example:}
\end{enumerate}
\subsection{Centrality}

Footblog has defined a notion of ``centrality'' for its users: a user's
``centrality'' is the minimum number of people they'd need to go through
to get a message to the person farthest from them on the network,
following ``enemy'' links. (The ``farthest'' person is exactly the one to
whom there is the longest minimum-length path of enemies.)

For this problem, \textbf{assume that the Footblog network does indeed form a single connected component.}

Briefly describe an algorithm to compute the centrality of a user
given a graph $G$ represented as a number of users $n > 0$ (where the
users themselves are vertices named $\{v_1, v_2, \ldots, v_n\}$, a
vertex number $i$ (where $1 \leq i \leq n$) of the user whose
centrality we wish to compute, and an adjacency list $A$ of edges
(i.e., an array of linked lists, where the entries in the list $A[j]$
are the vertex numbers of the users $j$ has ``enemied''). You may use
any common data structures you need. \textbf{Your algorithm must run in linear (i.e., $O(n + m)$ for $n$ nodes and $m$ edges) time.}


\begin{verbatim}
Centrality(n, i, A):
  // Fill in your algorithm here!
\end{verbatim}
\section{Heaps of Fun Might Be OK}

You're managing a major online tournament of the hot new game Flappy
Squirrel. There are a huge number of users, each with a
competitiveness rating (a floating point number). You need an
algorithm that---given a desired number of competitors $c$ and a list
of these competitiveness ratings (an array $A$ of length
$n$)---returns a list of the $c$ highest ratings. You're guaranteed
that $c \leq n$. (Note: we use 1-based indexing on arrays.)
\subsection{Algorithm 1}

Give and briefly justify a good asymptotic upper-bound (i.e., big-$O$
bound) on the runtime of the following algorithm to solve this
problem. (\textbf{Note:} the \texttt{buildMaxHeap} operation returns a max-heap
built from the elements of a given array of length $n$ in $O(n)$
time.)

\begin{verbatim}
TopC(A, c):
  best <- empty list
  h <- buildMaxHeap(A)
  for i = 1 to c:
    add findMax(h) to best
    deleteMax(h)
  return best
\end{verbatim}

\textbf{Answer: }The asymptotic upper-bound seems to be $O(cn)$. Given that \texttt{buildMaxHeap} operates at $O(n)$ we proceed to the \texttt{for} loop that executes $c$ times. In this loop, we call \texttt{deleteMax} which removes the maximum element in the heap and calls the necessary percolations to rebalance the heap. This should take $O(n)$. Hence, we have $n+1+c(1+n)+1 = O(cn)$.

\subsection{Algorithm 2}

Give and briefly justify a good asymptotic upper-bound (i.e., big-$O$
bound) on the runtime of the following algorithm to solve this
problem. (Note: the notation \texttt{A[1..c]} produces a list of the elements
\texttt{A[1], A[2], A[3], ..., A[c]} in $O(c)$ time.)

\begin{verbatim}
TopC(A, c):
  for i = 1 to c:
    maxIndex = i
    for j = i+1 to n:
      if A[j] > A[maxIndex]:
        maxIndex = j
    max = A[maxIndex]
    A[maxIndex] = A[i]
    A[i] = max
  return A[1..c]
\end{verbatim}

\textbf{Answer: }Algorithm 2 executes in $O(cn)$ time. The outer \texttt{for} loop  performs $c$ operations. The nested \texttt{for} loop performs  $n$ operations. Thus, by the end of algorithm we have $O(cn + c) = O(cn)$
\subsection{Algorithm 3}

Give and briefly justify a good asymptotic upper-bound (i.e., big-$O$
bound) on the runtime of the following algorithm to solve this
problem.

\begin{verbatim}
TopC(A, c):
  sort A using an efficient, comparison-based sorting algorithm
  return A[1..c]
\end{verbatim}

\textbf{Answer: }Using a QuickSort as our comparison-based sorting algorithm, it takes $O(n \lg n)$ to sort \texttt{A}. Then to \texttt{return A[1...c]} it takes $O(c)$. The upper bound is then $O(c+n \lg n)$.  
\subsection{Algorithm 4}

Give and briefly justify a good asymptotic upper-bound (i.e., big-$O$
bound) on the runtime of the following algorithm to solve this
problem. (Note: \texttt{Elements(h)} produces all elements in the heap \texttt{h} in
constant time, but \texttt{h} can no longer be used after that point.)

\begin{verbatim}
TopC(A, c):
  h <- empty min-heap
  for i = 1 to n:
    if Size(h) < c:
      Insert(h, A[i])
    else if A[i] > FindMin(h):
      DeleteMin(h)
      Insert(h, A[i])
  return Elements(h)
\end{verbatim}

\textbf{Answer: }Given that \texttt{Insert} operates in $O(\lg n)$, \texttt{FindMin} returns the minimum in constant time, and \texttt{DeleteMin} takes $O(n)$ to call the necssary percolations to re-heapify the array, the Algorithm operates in $O(n^2)$. The worst case runtime occurs when control is passed to the \texttt{else} statement, where we iterate $n$ times over $n+\lg n$ operations. 

\end{document} 